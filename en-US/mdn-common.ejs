<% module.exports = {
    
    /**
     * Given a set of strings like this:
     *     { "en-US": "Foo", "de": "Bar", "es": "Baz" }
     * Return the one which matches the current locale.
     */
    localString: function (strings) {
        var lang = env.locale;
        if (!(lang in strings)) lang = 'en-US';
        return strings[lang];
    },

    /**
     * DEVELOPMENTAL - DO NOT USE THIS IN PRODUCTION
     * Creates a localized internal link
     * path - path of the document to create link to. (Will handle old style links if necessary)
     * text (optional) - text of the link, defaults to page title
     * title (optional) - link title
     * locale (optional) - locale to link to. Only use if the link MUST be to another locale
     */

    linkInternal: function (in_path, in_text, in_title, in_locale) {
        var wiki = require("DekiScript:Wiki");
        var out = '(Missing path)';
  
        // No use doing anything if there is no path
        if (in_path) {
            var text = '';
            var path_kuma = wiki.kumaPath(in_path);
            var path_clean = path_kuma.replace(/[\?|#].*/,'');
            var queryElement = (path_kuma.match(/[\?|#].*/) || '');
            var path_less_locale = path_clean.replace(/^\/?\w{2}(?:-\w{2})?/i,'');
            var path_English = '/en-US' + path_less_locale;

            // Figure out locale to use (strip any / from in_locale)
            var locale = env.locale;
            if (in_locale) {
                locale = kuma.htmlEscape(in_locale.replace(/\//g,''));
            }
            var path_plus_locale = '/' + locale + path_less_locale;

            // Get text of link (title of page), if no override
            var text = '';
            if (in_text) {
                text = kuma.htmlEscape(in_text);
            }
            else {
                // Use path as fallback
                text = path_plus_locale;
                // If the locale version exists, get its title
                var pageLocale = wiki.getPage(path_plus_locale);
                if (pageLocale.title) {
                    text = pageLocale.title;
                }
                else {
                    // Try the original path passed, maybe the locale switch did not work
                    if (path_clean != path_plus_locale) {
                        var pageOriginal = wiki.getPage(path_clean);
                        if (pageOriginal.title) {
                            text = pageOriginal.title;
                        }
                    }
                    // Try the English version
                    else if (locale.toLowerCase() != 'en-us') {
                        var pageEnglish = wiki.getPage(path_English);
                        if (pageEnglish.title)  {
                            text = pageEnglish.title;
                        }
                    }
                }
            }
            out = '<a href="' + path_plus_locale + queryElement + '"';
            // Link title
            if (in_title) {
                out += ' title="' + kuma.htmlEscape(in_title) + '"';
            }
            out += '>' + text + '</a>';
        }
        return out;
    },
    /**
     * Accepts a relative URL or an attachment object
     * Returns the content of a given file.
     */
    getFileContent: function(fileObjOrUrl) {
        var url = fileObjOrUrl.url || fileObjOrUrl;
        if(!url) return '';
        
        var result = '',
            p = kuma.url.parse(env.url, true),
            base_url = p.protocol + '//' + p.host;
            
        url = base_url + url;
        return cacheFn('kuma:get_attachment_content:' + md5(url.toLowerCase()), 3600, function(next) {
            try {
                request({
                    method: 'GET',
                    headers: { 'Cache-Control': env.cache_control },
                    url: url
                }, function(err, resp, body) {
                    if(resp && 200 == resp.statusCode) {
                        next('[' + body + ']');
                    }
                    else {
                        next("callback bad :(");
                    }
                });
            } catch(e) {
                next("error: " + e);
            }
        });
    },

    /**
     * #### cacheFnIgnoreCacheControl
     * Cache a function, and use cached results no matter what 
     * Cache-Control we get from a shift-refresh.
     */
    cacheFnIgnoreCacheControl: function (key, tm_out, to_cache) {
        var result = null,
            err_result = null,
            f = new Future(),
            mc = memcached;
        mc.get(key, function (err, c_result) {
            if (c_result) {
                result = c_result;
                f['return']();
            } else {
                try {
                    to_cache(function (val) {
                        mc.set(key, val, tm_out, function (err, c_result) {
                            result = val;
                            f['return']();
                        });
                    });
                } catch (e) {
                    err_result = e;
                    result = '';
                    f['return']();
                }
            }
        });
        f.wait();
        if (err_result) { throw err_result; }
        return result;
    },
    
    // #### fetchJSONResource
    // Fetch an HTTP resource with JSON representation, parse the JSON and 
    // return a JS object.
    fetchJSONResource: function (url, cache_tmout) {
        if (!cache_tmout) cache_tmout = 3600;
        var key = 'kuma:json_resource:' + md5(url.toLowerCase());
        return cacheFn(key, 600, function (next) {
            var opts = {
                method: 'GET',
                headers: { 'Cache-Control': env.cache_control },
                url: url
            };
            try {
                request(opts, function (err, resp, body) {
                    var result = null;
                    if (resp && 200 == resp.statusCode) {
                        result = JSON.parse(body);
                    }
                    next(result);
                });
            } catch (e) {
                next(null);
            }            
        });
    }
} %>

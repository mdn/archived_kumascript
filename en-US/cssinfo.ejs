<% 
/*
  Displays general information about a CSS property or descriptor

  $0 - property/descriptor name - defaults to the slug name
  $1 - @-rule - defaults to the @-rule within the URL
*/

/**
 * Returns the initial value of a property or descriptor as formatted output
 * 
 * @param Object mdn Common functions library; needs to be passed to the 
 *        Function, otherwise the library is not available within it
 * @param String propertyOrDescriptor Name of the property or descriptor to 
 *        return the initial value for
 * @param String atRule Name of the @-Rule the descriptor belongs to
 * @returns String Formatted output for initial value
 */
function getInitialValueOutput(mdn, propertyOrDescriptor, atRule) {
    if (atRule) {
        if (data.atRules[atRule] && data.atRules[atRule].descriptors &&
            data.atRules[atRule].descriptors[propertyOrDescriptor]) {
            return data.atRules[atRule].descriptors[propertyOrDescriptor].
                initial;
        }
    } else if (data.properties[propertyOrDescriptor]) {
        var property = data.properties[propertyOrDescriptor];
        if (property.shorthand) {
            var initialValue = mdn.getLocalString(localStrings,
                "longhandConcatination") + "<ul>";
            property.longhands.forEach(function(longhand) {
                initialValue += "<li><code>" + longhand + "</code>: ";
                if (data.properties[longhand] &&
                    data.properties[longhand].shorthand) {
                    initialValue += getInitialValueOutput(mdn, longhand);
                } else {
                    initialValue += (data.properties[longhand] ?
                        data.properties[longhand].initial :
                        mdn.replacePlaceholders(formattedError,
                            [mdn.getLocalString(localStrings, "missing")]));
                }
                initialValue += "</li>";
            });
            initialValue += "</ul>";
            return initialValue;
        } else {
            return data.properties[propertyOrDescriptor].initial;
        }
    }

    return "";
}


function getComputedValueOutput(mdn, propertyOrDescriptor, atRule) {
    if (atRule) {
        if (data.atRules[atRule] && data.atRules[atRule].descriptors &&
            data.atRules[atRule].descriptors[propertyOrDescriptor]) {
            return data.atRules[atRule].descriptors[propertyOrDescriptor].
                computed || mdn.getLocalString(localStrings, "asSpecified");
        }
    } else if (data.properties[propertyOrDescriptor]) {
        var property = data.properties[propertyOrDescriptor];
        if (property.shorthand) {
            var computedValue =
                mdn.getLocalString(localStrings, "asLonghands") + "<ul>";
            property.longhands.forEach(function(longhand) {
                computedValue += "<li><code>" + longhand + "</code>: ";
                if (data.properties[longhand] &&
                    data.properties[longhand].shorthand) {
                    computedValue += getComputedValueOutput(mdn, longhand);
                } else {
                    computedValue += (data.properties[longhand] &&
                        data.properties[longhand].computed) ||
                        mdn.getLocalString(localStrings, "asSpecified");
                }
                computedValue += "</li>";
            });
            computedValue += "</ul>";
            return computedValue;
        } else {
            return data.properties[propertyOrDescriptor].computed ||
                mdn.getLocalString(localStrings, "asSpecified");
        }
    }
    
    return "";
}


function getAnimatableOutput(mdn, propertyOrDescriptor) {
    if (data.properties[propertyOrDescriptor]) {
        var property = data.properties[propertyOrDescriptor];
        if (property.shorthand) {
            var animatable = mdn.getLocalString(localStrings, "asLonghands") +
                "<ul>";
            property.longhands.forEach(function(longhand) {
                animatable += "<li><code>" + longhand + "</code>: ";
                if (data.properties[longhand] && data.properties[longhand].
                    shorthand) {
                    animatable += getAnimatableOutput(mdn, longhand);
                } else {
                    var animatableString =
                        data.properties[longhand].animatable !== "no" ?
                        mdn.replacePlaceholders(mdn.getLocalString(localStrings,
                            "yesAs"), [data.properties[longhand].animatable]) :
                        mdn.getLocalString(localStrings, "no");
                    animatable += (data.properties[longhand] ? animatableString : s_missing);
                }
                animatable += "</li>";
            });
            animatable += "</ul>";
            return animatable;
        } else {
            return data.properties[propertyOrDescriptor].animatable !== "no" ?
                mdn.replacePlaceholders(mdn.getLocalString(localStrings,
                    "yesAs"),
                    [data.properties[propertyOrDescriptor].animatable]) :
                mdn.getLocalString(localStrings, "no");
        }
    }

    return "";
}


/**
 * Returns the canonical order of the values of a property or descriptor as
 * formatted output
 * 
 * @param String order Order information, which may contain keywords
 * @returns String Formatted output for canonical order
 */
function getCanonicalOrderOutput(order) {
    if (!order) {
        return mdn.getLocalString(localStrings, "uniqueOrder");
    }

    if (order === "appearance") {
        return mdn.getLocalString(localStrings, "orderOfAppearance");
    }

    return order;
}


var data = string.deserialize(template("CSSData"));
var slug = env.slug;
var locale = env.locale;
var formattedError = "<span style=\"color:red;\">$1$</span>";

var name = $0 || slug.split("/").pop();
var atRule = $1;

var localStrings = {
    "missing": {
        "en-US": "Value not found in DB!",
        "de"   : "Wert nicht in der DB gefunden!"
    },
    "appliesTo": {
        "en-US" : "Applies to",
        "de" : "Anwendbar auf",
        "fr" : "S'applique à",
        "ja" : "適用対象",
        "zh-CN" : "适用元素"
    },
    "inherited": {
        "en-US": "Inherited",
        "de"   : "Vererbt"
    },
    // Plural form
    "media": {
        "en-US": "Media",
        "de"   : "Medien",
        "fr"   : "Média",
        "ja"   : "メディア",
        "zh-CN": "适用媒体" 
    },
    "yes": {
        "en-US": "yes",
        "de"   : "Ja",
        "fr"   : "oui",
        "ja"   : "継承する"
    },
    "no": {
        "en-US": "no",
        "de"   : "Nein",
        "fr"   : "non",
        "ja"   : "継承しない"
    },
    "longhandConcatination": {
        "en-US": "the concatenation of the initial values of its longhand properties:",
        "de"   : "Die Verkettung der Initialwerte der Langform Eigenschaften:",
        "fr"   : "La concaténation des valeurs initiales des propriétés associées :",
        "ja"   : "以下の各ロングハンドプロパティの初期値が使用されます:"
    },
    "asLonghands": {
        "en-US": "as each of the properties of the shorthand:",
        "de"   : "wie die jeweiligen Kurzschreibweisen:",
        "fr"   : "pour chaque propriété individuelle de la propriété raccourcie :",
        "ja"   : "以下の各プロパティのショートハンドとして補完します:",
        "ru"   : "как каждое из свойств этого сокращённого свойства:"
    },
    "asSpecified": {
        "en-US": "as specified",
        "de"   : "wie spezifiziert",
        "fr"   : "comme spécifié",
        "ja"   : "指定値",
    },
    "yesAs": {
        "en-US": "Yes, as $1$",
        "de"   : "Ja, als $1$",
    },
    "percentages": {
        "en-US": "Percentages",
        "de"   : "Prozentwerte",
        "fr"   : "Pourcentages",
        "ja"   : "相対値の基準"
    },
    "uniqueOrder": {     
      "en-US": "the unique non-ambiguous order defined by the formal grammar",
      "de"   : "die eindeutige Reihenfolge definiert durch die formale Grammatik",
      "fr"   : "l'ordre unique et non-ambigu défini par la grammaire formelle",
      "ja"   : "形式文法で定義される一意のあいまいでない順序"
    },
    "orderOfAppearance": {
        "en-US": "order of appearance in the formal grammar of the values",
        "de"   : "Reihenfolge des Auftretens in der formalen Grammatik der Werte",
        "fr"   : "l'ordre d'apparition dans la grammaire formelle des valeurs"
    }
};

var cssInfo = null;

if (!atRule) {
    var matches = slug.match(/\/CSS\/(@.+?)(?=\/)/);
    if (matches) {
        atRule = matches[1];
    }
}

if (atRule) {
    if (data.atRules[atRule] && data.atRules[atRule].descriptors) {
        cssInfo = data.atRules[atRule].descriptors[name];
    }
} else if (data.properties[name]) {
    cssInfo = data.properties[name];
}

var result = "";

if (cssInfo !== null) {
    result = "<ul class=\"cssprop\">";

    // Adds information about the initial value of the item to the output
    result += "<li><dfn>" + template("Xref_cssinitial") + "</dfn> " +
        getInitialValueOutput(mdn, name, atRule) + "</li>";

    // Adds information about to which elements the item applies to the output
    if (!atRule) {
        result += "<li><dfn>" + mdn.getLocalString(localStrings, "appliesTo") +
            "</dfn> " + cssInfo.appliesto + "</li>";
    }

    // Adds information about whether the item's value is inherited to the 
    // output
    result += "<li><dfn>" + template("Xref_cssinherited") + "</dfn> " +
        (cssInfo.inherited ?
            mdn.getLocalString(localStrings, "yes") :
            mdn.getLocalString(localStrings, "no")) +
        "</li>";

    // Adds information about how percentages are handled to the output 
    if (cssInfo.percentages !== "no") {
        result += "<li><dfn>" +
            mdn.getLocalString(localStrings, "percentages") + "</dfn> " +
            cssInfo.percentages + "</li>";
    }

    // Adds information about the media the item applies to to the output
    // We have a general link to @media here. When https://bugzil.la/1133414 is
    // fixed, we may change the link.
    result += "<li><dfn><a href=\"/" + locale + "/docs/Web/CSS/@media\">" +
        mdn.getLocalString(localStrings, "media") + "</a></dfn> " +
        cssInfo.media + "</li>";

    // Adds information about the computed value of the item to the output
    result += "<li><dfn>" + template("Xref_csscomputed") + "</dfn> " +
        getComputedValueOutput(mdn, name, atRule) + "</li>";

    // Adds information about whether the item is animatable to the output
    if (!atRule) {
        result += "<li><dfn>" + template("Xref_cssanimatable") + "</dfn> " +
            getAnimatableOutput(mdn, name, atRule) + "</li>";
    }

    // Adds information about the canonical order of the values of the item to
    // the output
    result += "<li><dfn>" + template("Xref_csscanonicalorder") + "</dfn> " +
        getCanonicalOrderOutput(cssInfo.order) + "</li>";

    result += "</ul>";
} else {
    result = mdn.replacePlaceholders(formattedError,
        [mdn.getLocalString(localStrings, "missing")]);
}
%><%- result %>

<%

/*
 * Embeds a custom compat table into the page using the Web Compat Services data.
 *
 * $0 - The feature slug to use.  (ex:  "css-display")
 */

var mdn = require('MDN:Common');

var url = encodeURI('https://browsercompat.herokuapp.com/api/v1/view_features/' + $0 + '.json');

var content = false;

var localStrings = string.deserialize(template('L10n:CompatTable'));

var localize = mdn.getLocalString;
var replacePlaceholders = mdn.replacePlaceholders;

var response = mdn.fetchCompatTableJSON(url);

if (response === null) {
    content = localize(localStrings, 'connectionFailure');
}
else if (response.errors) {
    content = replacePlaceholders(localize(localStrings, 'compatServiceError'), {error: JSON.stringify(response.errors)});
}

function loadTable(payload, locale) {

    var langDictionary = {
        "en-US": {
            // Browser Types
            browserTypes: {
                desktop: 'Desktop',
                mobile: 'Mobile',
                non: 'Non-Browser Environment'
            },

            // Basic yes and no
            supportsShort: {
                yes: 'Yes',
                no: 'No',
                parital: 'Partial'
            },

            // Support levels
            supportsLong: {
                yes: 'Full support',
                no: 'No support',
                partial: 'Partial support'
            },

            // Features, used in the left-most column
            features: {
                basicsupport: 'Basic Support',

                experimental: 'Experimental',
                experimentalLong: 'Experimental. Expect behavior to change in the future.',

                nonstandard: 'Non-standard',
                nonstandardLong: 'Non-standard. Expect poor cross-browser support.',

                obsolete: 'Obsolete',
                obsoleteLong: 'Obsolete. Not for use in new websites.'
            },
            
            // Version requirements
            requirements: {
                prefix: 'Prefixed',
                prefixLong: 'Requires the vendor prefix: <code>{prefix}</code>',

                note: 'Notes',
                noteLong: 'See implementation notes',

                alternate: 'Alternate Name',
                alternateLong: 'Uses the non-standard name: <code>{name}</code>',

                'protected': 'Protected',
                protectedLong: 'Protected. Additonal steps are required to get permission or certification for use.',

                disabled: 'Disabled',
                disabledRequires: 'The user must change <code>{default}</code> to <code>{requires}</code> to enable this feature.',
                disabledDefault: 'The user must change <code>{default}</code> to enable this feature.'
            },

            // Legend text
            legend: {
                heading: 'Legend',
                prefixLong: 'Requires a vendor prefix or different name for use.',
                alternateLong: 'Uses a non-standard name.',
                disabledLong: 'User must explicitly enable this feature.'
            }
        },

        // German dictionary for static strings
        "de": {
            // Browser Types
            browserTypes: {
                desktop: 'Desktop',
                mobile: 'Mobile',
                non: 'Nicht-Browser-Umgebung'
            },

            // Basic yes and no
            supportsShort: {
                yes: 'Ja',
                no: 'Nein',
                parital: 'Teilweise'
            },

            // Support levels
            supportsLong: {
                yes: 'Vollständige Unterstützung',
                no: 'Keine Unterstützung',
                partial: 'Teilweise Unterstützung'
            },

            // Features, used in the left-most column
            features: {
                basicsupport: 'Grundlegende Unterstützung',

                experimental: 'Experimentell',
                experimentalLong: 'Experimentell. Das Verhalten kann sich zukünftig ändern.',

                nonstandard: 'Nicht standardisiert',
                nonstandardLong: 'Nicht standardisiert. Erwarte schlechte browserübergreifende Unterstützung.',

                obsolete: 'Veraltet',
                obsoleteLong: 'Veraltet. Nicht zur Verwendung in neuen Webseiten geeignet.'
            },
            
            // Version requirements
            requirements: {
                prefix: 'mit Präfix',
                prefixLong: 'Benötigt das Herstellerpräfix: <code>{prefix}</code>',

                note: 'Hinweise',
                noteLong: 'Siehe Implementierungshinweise',

                alternate: 'Alternativer Name',
                alternateLong: 'Verwendet den nicht standardisierten Namen: <code>{name}</code>',

                'protected': 'Geschützt',
                protectedLong: 'Geschützt. Zusätzliche Schritte werden benötigt, um die Erlaubnis oder die Zertifizierung für den Gebrauch zu erhalten.',

                disabled: 'Deaktiviert',
                disabledRequires: 'Der Benutzer muss <code>{default}</code> ändern, um <code>{requires}</code> dieses Feature zu aktivieren.',
                disabledDefault: 'Der Benutzer muss <code>{default}</code> ändern, um dieses Feature zu aktivieren.'
            },

            // Legend text
            legend: {
                heading: 'Legende',
                prefixLong: 'Benötigt ein Herstellerpräfix oder einen anderen Namen zur Verwendung.',
                alternateLong: 'Verwendet einen nicht standardisierten Namen.',
                disabledLong: 'Benutzer muss dieses Feature explizit aktivieren.'
            }
        },

        // French dictionary for static strings
        "fr": {
            // Browser Types
            browserTypes: {
                desktop: 'Ordinateur',
                mobile: 'Mobile'
            },

            // Basic yes and no
            supportsShort: {
                yes: 'Oui',
                no: 'Non',
                parital: 'Partiel'
            },

            // Support levels
            supportsLong: {
                yes: 'Support complet',
                no: 'Aucun support',
                partial: 'Support partiel'
            },

            // Features, used in the left-most column
            features: {
                basicsupport: 'Support simple',

                experimental: 'Expérimentale',
                experimentalLong: 'Fonctionnalité experimentale. Celle-ci peut être amenée à changer par la suite.',

                nonstandard: 'Non-standard',
                nonstandardLong: 'Fonctionnalité non-standard. Celle-ci peut être incorrectement supportée par les autres navigateurs.',

                obsolete: 'Obsolète',
                obsoleteLong: 'Fonctionnalité obsolète. Celle-ci ne doit pas être utilisée pour de nouveaux sites web.'
            },
            
            // Version requirements
            requirements: {
                prefix: 'Préfixée',
                prefixLong: 'Nécessite l\'utilisation d\'un préfixe&nbsp;: <code>{prefix}</code>',

                note: 'Notes',
                noteLong: 'Voir les notes d\'implémentation',

                alternate: 'Autre nom',
                alternateLong: 'Cette fonctionnalité utilise le nom non-standard&nbsp;: <code>{name}</code>',

                'protected': 'Protégée',
                protectedLong: 'Cette fonctionnalité est protégée. Des étapes supplémentaires sont nécessaires pour pouvoir l\'utiliser.',

                disabled: 'Désactivée',
                disabledRequires: 'L\'utilisateur doit changer {default} à {requires} afin d\'activer cette fonctionnalité.',
                disabledDefault: 'L\'utilisateur doit changer {default} afin d\'activer cette fonctionnalité.'
            },

            // Legend text
            legend: {
                heading: 'Légende',
                prefixLong: 'Cette fonctionnalité nécessite un préfixe particulier ou utilise un autre nom.',
                alternateLong: 'Cette fonctionnalité utilise un nom non-standard.'
            }
        }
    };


    // Payload Shortcuts
    var tabs = payload.meta.compat_table.tabs;

    // Important Vars
    var numberOfBrowsers = getNumberOfBrowsers();

    // This is ultimately returned from the function
    var output = '';

    // Templates
    var templates = {
        icon: '<abbr title="{title}" class="only-icon"><span>{text}</span><i class="ic-{icon}" aria-hidden="true"></i></abbr>',
        iconx2: '<abbr title="{title}" class="only-icon"><span>{text}</span><i class="ic-{icon1}" aria-hidden="true"></i> <i class="ic-{icon2}" aria-hidden="true"></i></abbr>',
        support: '<abbr title="{title}" class="bc-level bc-level-{icon} only-icon"><span>{text}</span><img src="/media/img/wiki-compat-tables-support-sprite.gif" aria-hidden="true"></abbr>',
        legendItem: '<dt>{icon}</dt><dd>{text}</dd>'
    };
    templates.historySupport = templates.icon + ' {title}';

    // Conditions object so we know what to put into the legend
    var legendConditions = {
        // Support levels
        yes: false,
        partial: false,
        no: false,
        
        // Individual browser support details
        prefix: false,
        alternate: false,
        'protected': false,
        note: false,
        config: false,

        // Feature detail
        experimental: false,
        nonstandard: false,
        obsolete: false
    };

    // TABLE
    // ===============================
    output += '<table class="bc-table bc-table-' + numberOfBrowsers + '">';

    // HEADER
    // ===============================
    output += '<thead>';
    output += '<tr class="bc-mediums">';
    output += '<td></td>';
    tabs.forEach(function(tab) {

        output += _hackTableHeading(tab);

    });
    output += '</tr>';

    output += '<tr class="bc-browsers">';
    output += '<td></td>';
    tabs.forEach(function(tab, tabIndex) {
        // This is needed to differentiate groups of icons under desktop and mobile
        // The first cell in the mobile column requires an extra left border
        var addExtraLeftBorder = tabIndex ? 'bc-medium-border' : '';

        tab.browsers.forEach(function(browserId) {
            output += _hackBrowserIcons(browserId, addExtraLeftBorder);
            addExtraLeftBorder = '';
        });
    });
    output += '</tr>';

    output += '</thead>';

    // BODY
    // ===============================
    output += '<tbody>';

    // current feature aka Basic Support
    if (payload.features.links.supports.length > 0) {
        output += outputFeatureRow(payload.features, true);
    }

    // each linked feature
    payload.linked.features.forEach( function(feature){
        output += outputFeatureRow(feature);
    });

    output += '</tbody>';

    // Table close
    output += '</table>';

    
    // LEGEND
    // ===============================
    output += '<section class="bc-legend">';
    output += '<strong class="offscreen">' + localize(localStrings, 'legend') + '</strong>';
    output += '<dl>' + outputLegend() + '</dl>';
    output += '</section>';

    // Done!
    return output;




    // UTILITY FUNCTIONS
    // ===============================

    // creates a table row based on feature input
    function outputFeatureRow(feature, isBasicSupport) {
        isBasicSupport = typeof isBasicSupport !== 'undefined' ? isBasicSupport : false;
        var output = '';
        var name = getLocaleOrDefaultFromObject(feature.name);

        output += '<tr>';
        output += '<th scope="row">';
        if (isBasicSupport){
            output += localize(localStrings, 'features_basicsupport');
        }else if (nameIsCanonical(name, feature)) {
            output += '<code>' + name + '</code>';
        }
        else {
            output += name;
        }

        // Account for icons in this cell
        if (feature.experimental || feature.standardized === false || feature.obsolete) {

            output += '<div class="bc-icons">';
            if (feature.experimental) {
                output += getExperimentalIcon();
                setLegendCondition('experimental');
            }
            if (feature.standardized === false) {
                output += getNonStandardIcon();
                setLegendCondition('nonstandard');
            }
            if (feature.obsolete) {
                output += getObsoleteIcon();
                setLegendCondition('obsolute');
            }
            output += '</div>';

        }

        output += '</th>';

        tabs.forEach(function(tab, tabIndex) {
            // This is needed to differentiate groups of icons under desktop and mobile
            // The first cell in the mobile column requires an extra left border
            var addExtraLeftBorder = tabIndex > 0;

            tab.browsers.forEach(function(browserId) {
                var browserFeatureHistory = payload.meta.compat_table.supports[feature.id][browserId];
                var browserMeta = findObjectByIdInArray(browserId, payload.linked.browsers);
                var currentBrowserObj;
                var browserVersionObj;

                var cell = {
                    classes: [],
                    content: ''
                };

                // Apply the extra margin if first cell in second tab
                if (addExtraLeftBorder) {
                    cell.classes.push('bc-medium-border');
                    addExtraLeftBorder = false;
                }

                if (browserFeatureHistory) {

                    // Assume the last item is the "current"
                    // This will likely need to change in the future
                    currentBrowserObj = findObjectByIdInArray(browserFeatureHistory[browserFeatureHistory.length - 1], payload.linked.supports);

                    // Determine support via classname
                    cell.classes.push('bc-supports-' + currentBrowserObj.support);

                    // Build up the content 
                    // This is going to need a ton of logic 
                    browserVersionObj = findObjectByIdInArray(currentBrowserObj.links.version, payload.linked.versions);

                    // Add "Yes", "No", "Partial" or {version}
                    cell.content += getBrowserSupportText(browserVersionObj, currentBrowserObj);
                    cell.content += getSupportIcon(currentBrowserObj);

                    setLegendCondition(currentBrowserObj.support);

                    // Add icons for this individual history object
                    cell.content += outputIconsForHistoryObject(currentBrowserObj);

                    // History stuff goes here
                    var needsHistory = meetsHistoryCriteria(currentBrowserObj, browserFeatureHistory);
                    if (needsHistory) {

                        cell.classes.push('bc-has-history');

                        // Setup the section
                        cell.content += '<section class="bc-history hidden" aria-hidden="true"><dl>';

                        // Reverse the array to show support newest -> oldest
                        browserFeatureHistory.reverse();
                        browserFeatureHistory.forEach(function(historyItemId) {
                            var historyItemObject = findObjectByIdInArray(historyItemId, payload.linked.supports);
                            var historyItemVersionObject = findObjectByIdInArray(historyItemObject.links.version, payload.linked.versions);

                            cell.content += '<dt class="bc-supports-' + historyItemObject.support +' bc-supports">';

                            cell.content += getSupportIcon(historyItemObject);

                            // Add text for the version/support box
                            cell.content += getBrowserSupportText(historyItemVersionObject, historyItemObject);
                            cell.content += outputIconsForHistoryObject(historyItemObject);
                            
                            cell.content += '</dt>';

                            cell.content += '<dd>' + outputDetailsForHistoryObject(historyItemObject) + '</dd>';

                            setLegendCondition(historyItemObject.support);
                        });
                        cell.content += '</dl></section>';
                    }
                }
                else {
                    cell.classes.push('bc-supports-unknown');
                    cell.content += '?';
                }

                // Provide the browser class regardless of support
                cell.classes.push('bc-browser-' + browserMeta.slug);

                output += '<td class="' + cell.classes.join(' ') + '"> ' + cell.content + '</td>';

            });
        });

        output += '</tr>';
        return output;
    }

    function nameIsCanonical(name, feature){
        return (name == feature.name);
    }

    function meetsHistoryCriteria(currentBrowserObj, browserFeatureHistory) {
        if (browserFeatureHistory.length > 1){
            return true;
        } else if (meetsIconCriteria(currentBrowserObj)) {
            return true;
        } else {
            return false;
        }
    }

    // Simple true/false logic determining if a browser history object meets "extra info" criteria
    function meetsIconCriteria(historyObject) {
        return (historyObject.prefix_mandatory || 
            historyObject.alternate_name_mandatory || 
            historyObject['protected'] || 
            historyObject.note ||
            meetsConfigCriteria(historyObject)
        );
    }

    function meetsConfigCriteria(historyObject) {
        return historyObject.requires_config > 0 && historyObject.default_config != historyObject.requires_config;
    }

    // Evaluate a browser history object, place icons as needed
    function outputIconsForHistoryObject(historyObject) {
        var output = '';

        // Account for any required icons
        if (meetsIconCriteria(historyObject)) {

            output += '<div class="bc-icons">';

            // Browser Prefix
            if (historyObject.prefix_mandatory) {
                output += getPrefixIcon(historyObject);
                setLegendCondition('prefix');
            }

            // Alternate Name Mandatory
            if (historyObject.alternate_name_mandatory) {
                output += getAlternateIcon(historyObject);
                setLegendCondition('alternate');
            }

            // Requires/Default config
            if (meetsConfigCriteria(historyObject)) {
                output += getConfigIcon(historyObject);
                setLegendCondition('config');
            }

            // Protected
            if (historyObject['protected']) {
                output += getProtectedIcon();
                setLegendCondition('protected');
            }

            // Notes
            if (historyObject.note) {
                output += getNoteIcon();
                setLegendCondition('note');
            }

            output += '</div>';
        }

        return output;
    }


    // Evaluate a browser history object, place icons and detail text as needed
    function outputDetailsForHistoryObject(historyObject) {
        var output = '';

        // Account for any required icons
        if (meetsIconCriteria(historyObject)) {

            // Browser Prefix
            if (historyObject.prefix_mandatory) {
                output += getPrefixIcon(historyObject) + ' ' + getPrefixText(historyObject) + '<br>';
            }

            // Alternate Name Mandatory
            if (historyObject.alternate_name_mandatory) {
                output += getAlternateIcon(historyObject) + ' ' + getAlternateText(historyObject) + '<br>';
            }

            // Requires/Default config
            if (meetsConfigCriteria(historyObject)) {
                output += getConfigIcon(historyObject) + ' ' + getConfigText(historyObject) + '<br>';
            }

            // Protected
            if (historyObject['protected']) {
                output += getProtectedIcon() + 'FIX ME :: PROTECTED';
            }

            // Notes
            if (historyObject.note) {
                output += getNoteIcon() + getLocaleOrDefaultFromObject(historyObject.note) + '<br>';
            }

        }

        if (output === '') {
            output += '&nbsp';
        }

        return output;
    }

    // Outputs line items 
    function outputLegend() {
        var output = '';

        // Basic supports
        ['yes', 'partial', 'no'].forEach(function(key) {
            if (legendConditions[key]) {
                output += getLegendHTML('<span class="bc-supports-' + key + ' bc-supports">' + getSupportIcon({ support: key }) + '&nbsp;</span>', localize(localStrings, 'supportsLong_' + key));
            }
        });

        // Browser support details
        if (legendConditions.prefix) {
            output += getLegendHTML(getPrefixIcon(), localize(localStrings, 'legend_prefixLong'));
        }
        if (legendConditions.alternate) {
            output += getLegendHTML(getAlternateIcon(), getAlternateText());
        }
        if (legendConditions['protected']) {
            output += getLegendHTML(getProtectedIcon(), localize(localStrings, 'requirements_protectedLong'));
        }
        if (legendConditions.note) {
            output += getLegendHTML(getNoteIcon(), localize(localStrings, 'requirements_noteLong'));
        }
        if (legendConditions.config) { // FIX ME
            output += getLegendHTML(getConfigIcon(), localize(localStrings, 'legend_disabledLong'));
        }

        // Feature details
        if (legendConditions.experimental) {
            output += getLegendHTML(getExperimentalIcon(), localize(localStrings, 'features_experimentalLong'));
        }
        if (legendConditions.nonstandard) {
            output += getLegendHTML(getNonStandardIcon(), localize(localStrings, 'features_nonstandardLong'));
        }
        if (legendConditions.obsolete) {
            output += getLegendHTML(getObsoleteIcon(), localize(localStrings, 'features_obsoleteLong'));
        }

        return output;
    }


    // Set a legend condition key
    function setLegendCondition(key) {
        legendConditions[key] = true;
    }

    // Returns either the browser version number or "Yes" / "No" / "Partial"  for support text blocks
    function getBrowserSupportText(versionObj, browserObj) {
        if (versionObj && versionObj.version && versionObj.version != 'current') {
            return versionObj.version;
        }
        else {
            return localize(localStrings, 'supportsShort_' + browserObj.support); // PROBLEM:  This requires localization for "Yes" and "No"
        }
    }

    // Returns the total number of browsers, both desktop and mobile
    function getNumberOfBrowsers() {
        var numBrowsers = 0;

        tabs.forEach(function(tab) {
            numBrowsers += tab.browsers.length;
        });

        return numBrowsers;
    }

    // Tries to find the locale string for a given name object based on the navigator locale
    function getLocaleOrDefaultFromObject(nameObject) {
        return typeof nameObject === 'string' ? nameObject : (nameObject[locale] || nameObject[locale.split('-')[0]] || nameObject['en']);
    }

    // Given an array of objects, this finds the desired object based on provided ID
    function findObjectByIdInArray(id, array) {
        var match;
        array.forEach(function(obj) {
            if (match) return;
            if (obj.id === id) match = obj;
        });
        return match;
    }

    // Substitutes { key: value } objects into a template string
    // Example:  <abbr title="{title}" class="only-icon">    { title: 'Something' }
    function substitute(str, object) {
        return str.replace((/\\?\{([^{}]+)\}/g), function(match, name) {
            if (match.charAt(0) == '\\') return match.slice(1);
            return (object[name] !== null) ? object[name] : '';
        });
    }

    // ICON BUILDERS
    // ===============================
    function _getBasicIcon(langKey, longTextKey, shortTextKey, icon) {
        return substitute(templates.icon, {
                    title: localize(localStrings, langKey + '_' + longTextKey),
                    text: localize(localStrings, langKey + '_' + shortTextKey),
                    icon: (icon || shortTextKey)
                });
    }

    function getExperimentalIcon() {
        return _getBasicIcon('features', 'experimentalLong', 'experimental');
    }

    function getNonStandardIcon() {
        return _getBasicIcon('features', 'nonstandardLong', 'nonstandard', 'non-standard');
    }

    function getObsoleteIcon() {
        return _getBasicIcon('features', 'obsoleteLong', 'obsolete');
    }

    function getProtectedIcon() {
        return _getBasicIcon('requirements', 'protectedLong', 'protected');
    }

    function getNoteIcon() {
        return _getBasicIcon('requirements', 'noteLong', 'note', 'footnote');
    }

    function getConfigIcon(historyObject) {
        return substitute(templates.icon, {
                    title: getConfigText(historyObject),
                    text: localize(localStrings, 'requirements_disabled'),
                    icon: 'disabled'
                });
    }
    function getConfigText(historyObject) {
        return replacePlaceholders(localize(localStrings, 'requirements_' + (historyObject.requires_config && historyObject.default_config) ? 'disabledRequires' : 'disabledDefault'), {
                        'default': historyObject.default_config,
                        'requires': historyObject.requires_config
                    });
    }

    function getAlternateIcon(historyObject) {
        return substitute(templates.icon, {
                    title: getAlternateText(historyObject),
                    text: localize(localStrings, 'requirements_alternate'),
                    icon: 'altname'
                });
    }
    function getAlternateText(historyObject) {
        if (historyObject) {
            return replacePlaceholders(localize(localStrings, 'requirements_alternateLong'), {
                            prefix: historyObject ? historyObject.alternate_name : ''
                        });
        }
        else {
            return localize(localStrings, 'legend_alternateLong');
        }
        
    }

    function getPrefixIcon(historyObject) {
        return substitute(templates.icon, {
                    title: getPrefixText(historyObject),
                    text: localize(localStrings, 'requirements_prefix'),
                    icon: 'prefix'
                });
    }
    function getPrefixText(historyObject) {
        return replacePlaceholders(localize(localStrings, 'requirements_prefixLong'), {
                        prefix: historyObject ? historyObject.prefix : ''
                    });
    }

    function getSupportIcon(browserObj) {
        return substitute(templates.support, {
                        title: localize(localStrings, 'supportsLong_' + browserObj.support),
                        icon: browserObj.support,
                        text: localize(localStrings, 'supportsLong_' + browserObj.support)
                    });
    }

    function getLegendHTML(icon, text) {
        return substitute(templates.legendItem, {
            icon: icon,
            text: text
        });
    }



    // HACKS
    // ===============================
    // This section includes temporary hacks to make icons and such display properly

    function _hackTableHeading(tab) {
        var output = '';
        var tabName = getLocaleOrDefaultFromObject(tab.name);

        // Hacky vars
        var tabIcon = _hackEnvironmentIcon(tab);

        output += '<th colspan="' + tab.browsers.length +'" class="bc-medium-' + tabIcon + '">';

        output += substitute(templates.icon, {
            title: tabName,
            text: tabName,
            icon: tabIcon
        });

        output += '</th>';

        return output;
    }
    
    function _hackEnvironmentIcon(tab) {
        var tabName = tab.name.en.toLowerCase();
        var iconName = '';
        if (tabName.indexOf('desktop') != -1){
            iconName = 'desktop';
        } else if (tabName.indexOf('mobile') != -1) {
            iconName = 'mobile';
        } else if (tabName.indexOf('non-browser') != -1){
            iconName = 'non';
        }
        return iconName;
    }

    function _hackBrowserIcons(browserId, extraClass) {
        var output = '';
        var matchedBrowserObj = findObjectByIdInArray(browserId, payload.linked.browsers);
        var browserName = getLocaleOrDefaultFromObject(matchedBrowserObj.name);
        var icon = matchedBrowserObj.slug;
        var template = templates.icon;
        var substituteObject = {
            title: browserName,
            text: browserName, // PROBLEM:  No way of knowing "for Desktop" (localization issue)
            icon: icon
        };

        if (icon == 'chrome_desktop') {
            substituteObject.icon = 'chrome';
        }
        else if (icon == 'chrome_for_android') {
            template = templates.iconx2;
            substituteObject.icon1 = 'chrome';
            substituteObject.icon2 = 'android';
        }
        else if (icon == 'firefox_desktop') {
            substituteObject.icon = 'firefox';
        }
        else if (icon == 'firefox_android') {
            template = templates.iconx2;
            substituteObject.icon1 = 'firefox';
            substituteObject.icon2 = 'android';
        }
        else if (icon == 'ie_desktop' || icon == 'ie_mobile') {
            substituteObject.icon = 'ie';
        }
        else if (icon == 'opera_desktop') {
            substituteObject.icon = 'opera';
        }
        else if (icon == 'opera_mobile') {
            template = templates.iconx2;
            substituteObject.icon1 = 'opera';
            substituteObject.icon2 = 'mobile';
        }
        else if (icon == 'opera_mini') {
            template = templates.iconx2;
            substituteObject.icon1 = 'opera';
            substituteObject.icon2 = 'mini';
        }
        else if (icon == 'safari_desktop' || icon == 'safari_ios') {
            substituteObject.icon = 'safari';
        }
        else if (icon == 'android' || icon == 'android_webview') {
            substituteObject.icon = 'android_browser';
        }


        output += '<th class="bc-browser-' + icon + ' ' + extraClass + '">';

        output += substitute(template, substituteObject);

        output += '</th>';

        return output;
    }

}

if (!content) {
    content = loadTable(response, env.locale);
}

response = JSON.stringify(response);

%>
<div class="bc-api hidden">
<%-content%>
</div>
